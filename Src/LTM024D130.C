/****************************************Copyright (c)****************************************************
**                            Guangzhou ZHIYUAN electronics Co.,LTD.
**
**                                 http://www.embedtools.com
**
**------File Info-----------------------------------------------------------------------------------------
** File name:               LTM024D130.c
** Latest modified Date:    2008-07-22
** Latest Version:          1.0
** Descriptions:            TFT液晶LTM024D130的驱动文件
**
**--------------------------------------------------------------------------------------------------------
** Created by:              张展威
** Created date:            2008-07-22
** Version:                 1.0
** Descriptions:
**
**--------------------------------------------------------------------------------------------------------
** Modified by:
** Modified date:
** Version:
** Descriptions:
**
*********************************************************************************************************/


/*********************************************************************************************************
硬件寄存器相关操作头文件
*********************************************************************************************************/
#include  "includes.h"
#include  "hw_types.h"
#include  "hw_memmap.h"
#include  "hw_gpio.h"
#include  "sysctl.h"
#include  "gpio.h"

#include  "ff.h"
#include  "LTM024D130.h"
#include  "hz16.h"


#define INT8U  unsigned char
#define INT16U unsigned short


/*********************************************************************************************************
将较长的标识符定义成较短的形式
*********************************************************************************************************/
#define  SysCtlPeriEnable       SysCtlPeripheralEnable
#define  SysCtlPeriDisable      SysCtlPeripheralDisable
#define  GPIOPinTypeIn          GPIOPinTypeGPIOInput
#define  GPIOPinTypeOut         GPIOPinTypeGPIOOutput
#define  GPIOPinTypeOD          GPIOPinTypeGPIOOutputOD




/*********************************************************************************************************
硬件相关的定义
*********************************************************************************************************/
#define  LCD_CS_BASE_PIN        LCD_CS_BASE,LCD_CS_PIN
#define  LCD_WR_BASE_PIN        LCD_WR_BASE,LCD_WR_PIN
#define  LCD_RS_BASE_PIN        LCD_RS_BASE,LCD_RS_PIN
#define  LCD_RD_BASE_PIN        LCD_RD_BASE,LCD_RD_PIN
#define  LCD_RST_BASE_PIN       LCD_RST_BASE,LCD_RST_PIN
#define  LCD_EN_BASE_PIN        LCD_EN_BASE,LCD_EN_PIN
#define  DATA_PORT_BASE_PIN     DATA_PORT_BASE,DATA_PORT_PIN

/*********************************************************************************************************
硬件相关的位操作定义
*********************************************************************************************************/
#define  LCD_RS                 HWREG(LCD_RS_BASE + (GPIO_O_DATA + (LCD_RS_PIN << 2)))
#define  LCD_CS                 HWREG(LCD_CS_BASE + (GPIO_O_DATA + (LCD_CS_PIN << 2)))
#define  LCD_WR                 HWREG(LCD_WR_BASE + (GPIO_O_DATA + (LCD_WR_PIN << 2)))
#define  LCD_RD                 HWREG(LCD_RD_BASE + (GPIO_O_DATA + (LCD_RD_PIN << 2)))
#define  LCD_RST                HWREG(LCD_RST_BASE + (GPIO_O_DATA + (LCD_RST_PIN << 2)))
#define  LCD_EN                 HWREG(LCD_EN_BASE + (GPIO_O_DATA + (LCD_EN_PIN << 2)))
#define  DATA_PORT              HWREG(DATA_PORT_BASE + (GPIO_O_DATA + (DATA_PORT_PIN << 2)))
#define  DATA_PROT_INPUT_SET()  HWREG(DATA_PORT_BASE + GPIO_O_DIR) = 0  /* 设置数据口为输入方向         */
#define  DATA_PROT_OUTPUT_SET() HWREG(DATA_PORT_BASE + GPIO_O_DIR) = 0xFF
                                                                        /* 设置数据口为输出方向         */

/*********************************************************************************************************
  CONSTANTS 常量
*********************************************************************************************************/

  FATFS fs;             
  FIL fsrc;             
  BYTE buffer[240*8];   
  FRESULT res;          
  WORD br, bw;     

/*********************************************************************************************************
** 函数名称: __writeRegAddr8
** 功能描述: 写寄存器地址函数
** 输  　入: ucAddr 8位的液晶寄存器地址
** 输　  出: 无
** 全局变量: 无
** 调用模块: 无
** 返    回：无
** 作  　者: 张展威
** 日　  期: 2008年7月22日
**------------------------------------------------------------------------------------------------------
** 修 改 人:
** 日　  期:
**------------------------------------------------------------------------------------------------------
*********************************************************************************************************/
void __writeRegAddr8(INT8U ucAddr)                                      /* 写寄存器地址函数             */
{
    LCD_CS = 0x00;                                                      /* 拉低CS                       */
    LCD_RS = 0x00;                                                      /* 拉低RS                       */
    DATA_PORT = ucAddr;                                                 /* 写地址数据                   */
    LCD_WR = 0x00;                                                      /* 拉低WR                       */
    LCD_WR = 0xFF;                                                      /* 拉高WR                       */
    //LCD_RS = 0xFF;                                                    /* 拉高RS                       */
    LCD_CS = 0xFF;                                                      /* 拉高CS                       */
}

/*********************************************************************************************************
** 函数名称: __writeData8
** 功能描述: （向当前地址的寄存器）写8位数据
** 输  　入: ucData 要写入液晶的8位数据
** 输　  出: 无
** 全局变量: 无
** 调用模块: 无
** 返    回：无
** 作  　者: 张展威
** 日　  期: 2008年7月22日
**------------------------------------------------------------------------------------------------------
** 修 改 人:
** 日　  期:
**------------------------------------------------------------------------------------------------------
*********************************************************************************************************/
void __writeData8(INT8U ucData)                                         /* 写8位数据函数                */
{
    LCD_CS = 0x00;                                                      /* 拉低CS                       */
    LCD_RS = 0xFF;                                                      /* 拉高RS                       */
    DATA_PORT = ucData;                                                 /* 写数据                       */
    LCD_WR = 0x00;                                                      /* 拉低WR                       */
    LCD_WR = 0xFF;                                                      /* 拉高WR                       */
    LCD_CS = 0xFF;                                                      /* 拉高CS                       */
}

/*********************************************************************************************************
** 函数名称: __readData8
** 功能描述: （从当前地址的寄存器）读8位数据
** 输  　入: 无
** 输　  出: 无
** 全局变量: 无
** 调用模块: 无
** 返    回：（当前地址的）8位数据
** 作  　者: 张展威
** 日　  期: 2008年7月22日
**------------------------------------------------------------------------------------------------------
** 修 改 人:
** 日　  期:
**------------------------------------------------------------------------------------------------------
*********************************************************************************************************/
unsigned char __readData8(void)
{
    unsigned char ucReturn = 0;
    DATA_PROT_INPUT_SET();                                              /* 设置数据口为输入方向         */
    LCD_CS = 0x00;                                                      /* 拉低CS                       */
    LCD_RS = 0xFF;                                                      /* 拉高RS                       */
    LCD_RD = 0x00;                                                      /* 拉低RD                       */
    LCD_RD = 0xFF;                                                      /* 拉高RD                       */
    ucReturn = DATA_PORT;                                               /* 读入数据                     */
    LCD_CS = 0xFF;                                                      /* 拉高CS                       */
    DATA_PROT_OUTPUT_SET();                                             /* 还原为输出端口               */
    return ucReturn;                                                    /* 返回结果                     */
}


/*********************************************************************************************************
** 函数名称: __writeRegAddr16
** 功能描述: 写寄存器地址函数
** 输  　入: usAddr 16位的液晶寄存器地址
** 输　  出: 无
** 全局变量: 无
** 调用模块: 无
** 返    回：无
** 作  　者: 张展威
** 日　  期: 2008年7月22日
**------------------------------------------------------------------------------------------------------
** 修 改 人:
** 日　  期:
**------------------------------------------------------------------------------------------------------
*********************************************************************************************************/
void __writeRegAddr16(unsigned short usAddr)
{
    LCD_CS = 0x00;                                                      /* 拉低CS                       */
    LCD_RS = 0x00;                                                      /* 拉低RS                       */
    DATA_PORT = (unsigned char)(usAddr >> 8);                           /* 写地址高8位数据              */
    LCD_WR = 0x00;                                                      /* 拉低WR                       */
    LCD_WR = 0xFF;                                                      /* 拉高WR                       */
    DATA_PORT = (unsigned char)usAddr;                                  /* 写地址低8位数据              */
    LCD_WR = 0x00;                                                      /* 拉低WR                       */
    LCD_WR = 0xFF;                                                      /* 拉高WR                       */
    //LCD_RS = 0xFF;                                                    /* 拉高RS                       */
    LCD_CS = 0xFF;                                                      /* 拉高CS                       */
}


/*********************************************************************************************************
** 函数名称: __readData16
** 功能描述: （从当前地址的寄存器）读16位数据函数
** 输  　入: 无
** 输　  出: 无
** 全局变量: 无
** 调用模块: 无
** 返    回：（当前地址的）16位数据
** 作  　者: 张展威
** 日　  期: 2008年7月22日
**------------------------------------------------------------------------------------------------------
** 修 改 人:
** 日　  期:
**------------------------------------------------------------------------------------------------------
*********************************************************************************************************/
unsigned short __readData16(void)
{
    unsigned short usRetrun = 0;
    
    DATA_PROT_INPUT_SET();                                              /* 设置数据口为输入方向         */
    LCD_CS = 0x00;                                                      /* 拉低CS                       */
    LCD_RS = 0xFF;                                                      /* 拉高RS                       */
    LCD_RD = 0x00;                                                      /* 拉低RD                       */
    usRetrun = DATA_PORT;                                               /* 读入高8位数据                */
    LCD_RD = 0xFF;                                                      /* 拉高RD                       */
    LCD_RD = 0x00;                                                      /* 拉低RD                       */
    usRetrun = (usRetrun << 8) + DATA_PORT;                             /* 读入低8位数据                */
    LCD_RD = 0xFF;                                                      /* 拉高RD                       */
    LCD_CS = 0xFF;                                                      /* 拉高CS                       */
    DATA_PROT_OUTPUT_SET();                                             /* 还原为输出端口               */
    return usRetrun;
}


/*********************************************************************************************************
** 函数名称: pixelRead
** 功能描述: 从指定坐标位置读出16位的颜色数据
** 输  　入: x 列坐标
**           y 行坐标
** 输　  出: 无
** 全局变量: 无
** 调用模块: DATA_PROT_INPUT_SET()、DATA_PROT_OUTPUT_SET()
** 返    回：GRAM中指定坐标的16位的颜色数据
** 作  　者: 张展威
** 日　  期: 2008年7月22日
**------------------------------------------------------------------------------------------------------
** 修 改 人:
** 日　  期:
**------------------------------------------------------------------------------------------------------
*********************************************************************************************************/
unsigned short pixelRead(unsigned short x, unsigned short y)
{
    unsigned short usRetrun = 0;
    
    __writeCommand(0, 0x02, (unsigned char)x);                          /* X （0～239）                 */
    __writeCommand(1, 0x03, y);                                         /* Y （0～319）                 */
    __writeRegAddr8(0x0F);                                              /* GRAM读接口寄存器地址         */
    DATA_PROT_INPUT_SET();                                              /* 设置数据口为输入方向         */
    LCD_CS = 0x00;                                                      /* 拉低CS                       */
    LCD_RS = 0xFF;                                                      /* 拉高RS                       */
    LCD_RD = 0x00;                                                      /* 拉低RD                       */
    LCD_RD = 0xFF;                                                      /* 拉高RD                       */
    LCD_RD = 0x00;                                                      /* 拉低RD                       */
    LCD_RD = 0xFF;                                                      /* 拉高RD                       */
    LCD_RD = 0x00;                                                      /* 拉低RD                       */
    usRetrun = DATA_PORT;                                               /* 读入高8位数据                */
    LCD_RD = 0xFF;                                                      /* 拉高RD                       */
    LCD_RD = 0x00;                                                      /* 拉低RD                       */
    usRetrun = (usRetrun << 8) + DATA_PORT;                             /* 读入低8位数据                */
    LCD_RD = 0xFF;                                                      /* 拉高RD                       */
    LCD_CS = 0xFF;                                                      /* 拉高CS                       */
    DATA_PROT_OUTPUT_SET();                                             /* 还原为输出端口               */
    return usRetrun;
}

/*********************************************************************************************************
** 函数名称: __writeData16
** 功能描述: （向当前地址的寄存器）写16位数据
** 输  　入: usData 要写入液晶的16位数据
** 输　  出: 无
** 全局变量: 无
** 调用模块: 无
** 返    回：无
** 作  　者: 张展威
** 日　  期: 2008年7月22日
**------------------------------------------------------------------------------------------------------
** 修 改 人:
** 日　  期:
**------------------------------------------------------------------------------------------------------
*********************************************************************************************************/
void __writeData16(INT16U usData)                                       /* 写16位数据函数               */
{
    LCD_CS = 0x00;
    LCD_RS = 0xFF;                                                      /* 拉高RS                       */
    DATA_PORT = (INT8U)(usData>>8);                                     /* 写高8位数据                  */
    LCD_WR = 0x00;                                                      /* 拉低WR                       */
    LCD_WR = 0xFF;                                                      /* 拉高WR                       */
    DATA_PORT = (INT8U)usData;                                          /* 写低8位数据                  */
    LCD_WR = 0x00;                                                      /* 拉低WR                       */
    LCD_WR = 0xFF;                                                      /* 拉高WR                       */
    //LCD_RS = 0xFF;                                                    /* 拉高RS                       */
    LCD_CS = 0xFF;                                                      /* 拉高CS                       */
}




/*********************************************************************************************************
** 函数名称: __writeCommand
** 功能描述: 写命令函数
** 输  　入: bCmdWidth 0,命令字为8位；1,命令字为16位
**           ucAddr 命令寄存器地址
**           usCmd  命令字
** 输　  出: 无
** 全局变量: 无
** 调用模块: 无
** 返    回：无
** 作  　者: 张展威
** 日　  期: 2008年7月22日
**------------------------------------------------------------------------------------------------------
** 修 改 人:
** 日　  期:
**------------------------------------------------------------------------------------------------------
*********************************************************************************************************/
void __writeCommand(BOOLEAN bCmdWidth,INT8U ucAddr,INT16U usCmd)
{
    // 写8位地址
    LCD_CS = 0x00;
    LCD_RS = 0x00;                                                      /* 拉低RS                       */
    DATA_PORT = ucAddr;
    LCD_WR = 0x00;
    LCD_WR = 0xFF;
    LCD_RS = 0xFF;                                                      /* 拉高RS                       */
    if(bCmdWidth) {
        // 高8位数据
        //LCD_RS = 0xFF;                                                /* 拉高RS                       */
        DATA_PORT = (INT8U)(usCmd >> 8);
        LCD_WR = 0x00;
        LCD_WR = 0xFF;
    }
    // 低8位数据
    DATA_PORT = (INT8U)usCmd;
    LCD_WR = 0x00;
    LCD_WR = 0xFF;
    LCD_CS = 0xFF;
}


/*********************************************************************************************************
** 函数名称: windowset
** 功能描述: 窗口设置
** 输  　入: x1,y1 窗口起始坐标
**           x2,y2 窗口结束坐标
** 输　  出: 无
** 全局变量: 无
** 调用模块: __writeCommand()
** 返    回：无
** 作  　者: 张展威
** 日　  期: 2008年7月22日
**------------------------------------------------------------------------------------------------------
** 修 改 人:
** 日　  期:
**------------------------------------------------------------------------------------------------------
*********************************************************************************************************/
void windowset(unsigned short x1, unsigned short y1, unsigned short x2, unsigned short y2)
{
    __writeCommand(0,0x06, x1);                                         /* 水平起始位置                 */
    __writeCommand(1,0x07, y1);                                         /* 垂直起始位置                 */
    __writeCommand(0,0x04, x2);                                         /* 结束列数(0~239)              */
    __writeCommand(1,0x05, y2);                                         /* 结束行数(0~319)              */
}


/*********************************************************************************************************
** 函数名称: tftLcdInit
** 功能描述: 液晶初始化
** 输  　入: 无
** 输　  出: 无
** 全局变量: 无
** 调用模块: __writeCommand()、windowset()、__screenFill()
** 返    回：无
** 作  　者: 张展威
** 日　  期: 2008年7月22日
**------------------------------------------------------------------------------------------------------
** 修 改 人:
** 日　  期:
**------------------------------------------------------------------------------------------------------
*********************************************************************************************************/
void tftLcdInit(void)                                                   /* 初始化函数                   */
{
    SysCtlPeriEnable(LCD_PERI);                                         /* 使能相应的GPIO               */
    GPIOPinTypeOut(LCD_CS_BASE_PIN);                                    /* 设置相应的控制管脚为输出     */
    GPIOPinTypeOut(LCD_WR_BASE_PIN);                                    /* 设置相应的控制管脚为输出     */
    GPIOPinTypeOut(LCD_RS_BASE_PIN);                                    /* 设置相应的控制管脚为输出     */
    GPIOPinTypeOut(LCD_RD_BASE_PIN);                                    /* 设置相应的控制管脚为输出     */
    GPIOPinTypeOut(LCD_RST_BASE_PIN);                                   /* 设置相应的控制管脚为输出     */
    GPIOPinTypeOut(LCD_EN_BASE_PIN);                                   /* 设置相应的控制管脚为输出     */
    GPIOPinTypeOut(DATA_PORT_BASE_PIN);                                 /* 设置相应的数据管脚为输出     */
    
    LCD_RS = 0xFF;                                                      /* 初始化输出为高电平           */
    LCD_CS = 0xFF;                                                      /* 初始化输出为高电平           */
    LCD_WR = 0xFF;;                                                     /* 初始化输出为高电平           */
    LCD_RD = 0xFF;                                                      /* 初始化输出为高电平           */
    LCD_RST = 0xFF;                                                     /* 初始化输出为高电平           */
    DATA_PORT = 0xFF;
    
    LCD_RST = 0x00;                                                     /* 拉低复位引脚                 */
    SysCtlDelay(10 * SysCtlClockGet() / 3000);
    LCD_RST = 0xFF;                                                     /* 拉高复位引脚                 */
    SysCtlDelay(10 * SysCtlClockGet() / 3000);
    
    //initializing funciton 1
    
    
    __writeCommand(0,0xA1,0x00);
    __writeCommand(0,0xA0,0x00);
    __writeCommand(0,0x70,0xC8);
    SysCtlDelay(2 * SysCtlClockGet() / 3000);
    
    __writeCommand(0,0x72,0xA3);
    __writeCommand(0,0x73,0x04);
    __writeCommand(0,0x75,0x45);
    __writeCommand(0,0x76,0x23);
    __writeCommand(0,0x77,0x08);
    __writeCommand(0,0x78,0x08);
    __writeCommand(0,0x79,0x00);
    __writeCommand(0,0x7F,0xF0);
    __writeCommand(0,0x71,0x81);
    SysCtlDelay(2 * SysCtlClockGet() / 3000);
    
    __writeCommand(0,0x0D,0x23);
    __writeCommand(0,0x11,0x00);
    __writeCommand(0,0x12,0x00);
    __writeCommand(0,0x21,0x37);
    __writeCommand(0,0x22,0x02);
    __writeCommand(0,0x23,0x24);
    __writeCommand(0,0x24,0x13);
    __writeCommand(0,0x25,0x0A);
    __writeCommand(0,0x26,0x82);
    __writeCommand(0,0x27,0x01);
    __writeCommand(0,0x1E,0x25);
    __writeCommand(0,0x1F,0x59);
    
    //GAMMA设置
    __writeCommand(1,0x30,0x0777);
    __writeCommand(1,0x31,0x0444);
    __writeCommand(1,0x32,0x0555);
    __writeCommand(1,0x33,0x0444);
    __writeCommand(1,0x34,0x0333);
    __writeCommand(1,0x35,0x0333);
    __writeCommand(1,0x36,0x0333);
    __writeCommand(1,0x37,0x0333);
    __writeCommand(1,0x38,0x0444);
    __writeCommand(1,0x39,0x0555);
    __writeCommand(1,0x3A,0x0666);
    __writeCommand(1,0x3B,0x0666);
    __writeCommand(1,0x3C,0x0777);
    __writeCommand(1,0x3D,0x0777);
    __writeCommand(1,0x3E,0x0777);
    __writeCommand(1,0x3F,0x0777);
    __writeCommand(1,0x40,0x0777);
    __writeCommand(1,0x41,0x0777);
    __writeCommand(1,0x42,0x0777);
    __writeCommand(1,0x43,0x0777);
    __writeCommand(1,0x44,0x0777);
    __writeCommand(1,0x45,0x0777);
    __writeCommand(1,0x46,0x0777);
    __writeCommand(1,0x47,0x0777);
    __writeCommand(1,0x48,0x0777);
    __writeCommand(1,0x49,0x0777);
    __writeCommand(1,0x4A,0x0777);
    __writeCommand(1,0x4B,0x0777);
    __writeCommand(1,0x4C,0x0777);
    __writeCommand(1,0x4D,0x0666);
    __writeCommand(1,0x4E,0x0666);
    __writeCommand(1,0x4F,0x0666);
    
    //扫描方向控制
    __writeCommand(0,0x00,0x04);                                        /* 扫描方向控制                 */
    __writeCommand(0,0x01,0x07);                                        /* 扫描方向控制                 */
    
    //窗口设置
    windowset(0, 0, 239, 319);
    
    __writeCommand(0,0x08, 239);                                        /* 水平结束位置                 */
    __writeCommand(1,0x09, 319);                                        /* 垂直结束位置                 */
    
    //坐标设置
    __writeCommand(0,0x02,0x00);                                        /* X （0～239）                 */
    __writeCommand(1,0x03,0x0000);                                      /* Y （0～319）                 */

    __writeCommand(0,0x0A,0x00);
    __writeCommand(0,0x0B,0x00);
    __writeCommand(0,0x0C,0x00);
    __writeCommand(0,0x14,0x00);
    __writeCommand(0,0x15,0x00);
    __writeCommand(0,0x16,0x00);
    __writeCommand(1,0x17,0x01FF);
    __writeCommand(1,0x18,0x01FF);
    __writeCommand(0,0x13,0x00);
    __writeCommand(1,0x19,0x01FF);
    __writeCommand(1,0x1B,0x01FF);
    __writeCommand(1,0x1C,0x01FF);
    __writeCommand(1,0x1A,0x01FF);
    __writeCommand(0,0x1D,0x0E);
    
    __screenFill(GusBACKCOLOR);                                         /* 填充背景色                   */
    __writeCommand(0,0x10,0x06);                                        /* 开显示                       */
}




/*********************************************************************************************************
** 函数名称: setCoordinate
** 功能描述: 写绘图坐标
** 输  　入: x 起点所在列的位置
**           y 起点所在行的位置
** 输　  出: 无
** 全局变量: 无
** 调用模块: __writeCommand()、windowset()、__writeData16()
** 返    回：无
** 作  　者: 张展威
** 日　  期: 2008年7月22日
**------------------------------------------------------------------------------------------------------
** 修 改 人:
** 日　  期:
**------------------------------------------------------------------------------------------------------
*********************************************************************************************************/
void setCoordinate(unsigned short x, unsigned short y)
{
    //起始坐标
    __writeCommand(0, 0x02, (unsigned char)x);                          /* X （0～239）                 */
    __writeCommand(1, 0x03, y);                                         /* Y （0～319）                 */
    __writeRegAddr8(0x0E);                                              /* GRAM写接口寄存器地址         */
}

void __screenFill(unsigned short usPixValue)
{
    unsigned long i = 0;
    //扫描方向控制
    __writeCommand(0,0x00,0x04);                                        /* 扫描方向控制                 */
    __writeCommand(0,0x01,0x07);                                        /* 扫描方向控制                 */
    
    
    //面板大小设置
    __writeCommand(0,0x04,0xEF);                                        /* 结束列数(0~239)              */
    __writeCommand(1,0x05,0x013F);                                      /* 结束行数(0~319)              */
    
    //窗口设置
    windowset(0, 0, 239, 319);
    
    //起始坐标
    setCoordinate(0,0);
    for(i=0;i < (240 * 320);i++) {                                      /* 填充像素值                   */
        __writeData16(usPixValue);                                      /* 发送像素值                   */
    }
}




/*********************************************************************************************************
** 函数名称: __writeOneHzChar
** 功能描述: 在指定的起始坐标处写一个汉字
** 输  　入: pucMsk 指向汉字字模存放的起始地址
**           x0 起始坐标所在列的位置
**           y0 起始坐标所在行的位置
**           color 字符显示的颜色
** 输　  出: 无
** 全局变量: 无
** 调用模块: setCoordinate()、__writeData16()、__readData16()
** 返    回：所写字符的列宽16
** 作  　者: 张展威
** 日　  期: 2008年7月22日
**------------------------------------------------------------------------------------------------------
** 修 改 人:
** 日　  期:
**------------------------------------------------------------------------------------------------------
*********************************************************************************************************/
unsigned long __writeOneHzChar(unsigned char *pucMsk,
                               unsigned short x0,
                               unsigned short y0,
                               unsigned short color)
{
    unsigned long i,j;
    unsigned short mod[16];                                             /* 当前字模                     */
    unsigned short *pusMsk;                                             /* 当前字库地址                 */
    unsigned short y;
    
    pusMsk = (unsigned short *)pucMsk;
    for(i=0; i<16; i++)                                                 /* 保存当前汉字点阵式字模       */
    {
        mod[i] = *pusMsk++;                                             /* 取得当前字模，半字对齐访问   */
        mod[i] = ((mod[i] & 0xff00) >> 8) | ((mod[i] & 0x00ff) << 8);   /* 字模交换高低字节（为了显示   */
                                                                        /* 需要）                       */
    }
    y = y0;
    for(i=0; i<16; i++) {                                               /* 16行                         */
        #ifdef __DISPLAY_BUFFER                                         /* 使用显存显示                 */
        for(j=0; j<16; j++) {                                           /* 16列                         */
            if((mod[i] << j)& 0x8000) {                                 /* 显示字模                     */
                DispBuf[240*(y0+i) + x0+j] = color;
            }
        }
        #else                                                           /* 直接显示                     */
        
        setCoordinate(x0, y);                                           /* 设置写数据地址指针           */
        for(j=0; j<16; j++) {                                           /* 16列                         */
            if((mod[i] << j) & 0x8000) {                                /* 显示字模                     */
                __writeData16(color);
            } else {
                __readData16();                                         /* 用读方式跳过写空白点的像素   */
            }
        }
        y++;
        #endif
    }
    return (16);                                                        /* 返回16位列宽                 */
}



/*********************************************************************************************************
** 函数名称: __writeOneASCII
** 功能描述: 在指定的起始坐标处写一个ASCII码字符
** 输  　入: pucMsk 指向ASCII码字符字模存放的起始地址
**           x0 起始坐标所在列的位置
**           y0 起始坐标所在行的位置
**           color 字符显示的颜色
** 输　  出: 无
** 全局变量: 无
** 调用模块: setCoordinate()、__writeData16()、__readData16()
** 返    回：所写字符的列宽8
** 作  　者: 张展威
** 日　  期: 2008年7月22日
**------------------------------------------------------------------------------------------------------
** 修 改 人:
** 日　  期:
**------------------------------------------------------------------------------------------------------
*********************************************************************************************************/
unsigned long __writeOneASCII(unsigned char *pucMsk,
                              unsigned short x0,
                              unsigned short y0,
                              unsigned short color)
{
    unsigned long i,j;
    unsigned short y;
    unsigned char ucChar;
    
    y = y0;
    for(i=0; i<16; i++) {                                               /* 16行                         */
        ucChar = *pucMsk++;
        #ifdef __DISPLAY_BUFFER                                         /* 使用显存显示                 */
        for(j=0; j<8; j++) {                                            /* 8列                          */
            if((ucChar << j)& 0x80) {                                   /* 显示字模                     */
                DispBuf[240*(y0+i) + x0+j] = color;
            }
        }
        #else                                                           /* 直接显示                     */
        
        setCoordinate(x0, y);                                           /* 设置写数据地址指针           */
        for(j=0; j<8; j++) {                                            /* 8列                          */
            if((ucChar << j) & 0x80) {                                  /* 显示字模                     */
                __writeData16(color);
            } else {
                __readData16();
            }
        }
        y++;
        #endif
    }
    return (8);                                                         /* 返回16位列宽                 */
}



/*********************************************************************************************************
** 函数名称: writeString
** 功能描述: 在指定的坐标处开始显示字符串
** 输  　入: pcStr 字符串存放首地址
**           x0 起始坐标所在列的位置
**           y0 起始坐标所在行的位置
**           color 字符串的显示颜色
** 输　  出: 无
** 全局变量: GBHZ_16 自定义汉字库字模数表
**           ASCII   自定义的ASCII码字库字模数表
** 调用模块: findHzIndex()、__writeOneHzChar()、__writeOneASCII()
** 作  　者: 张展威
** 日　  期: 2008年7月22日
**------------------------------------------------------------------------------------------------------
** 修 改 人:
** 日　  期:
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
void writeString(unsigned char *pcStr, unsigned short x0, unsigned short y0, unsigned short color)
{
    unsigned short usIndex;
    unsigned short usWidth = 0;
    FNT_GB16 *ptGb16 = 0;
    
    ptGb16 = (FNT_GB16 *)GBHZ_16;                                       /*                              */
    while(1)
    {
        if(*pcStr == 0) {
            break;                                                      /* 字符串结束                   */
        }
        
        x0 = x0 + (usWidth);                                            /* 调节字符串显示松紧度         */
        if(*pcStr > 0x80) {                                             /* 判断为汉字                   */
            if((x0 + 16) >= Gus_LCM_XMAX) {                             /* 检查剩余空间是否足够         */
                x0 = 0;
                y0 = y0 + 16;                                           /* 改变显示坐标                 */
                if(y0 >= Gus_LCM_YMAX) {                                /* 纵坐标超出                   */
                    y0 = 0;
                }
            }
            usIndex = findHzIndex(pcStr);
            usWidth = __writeOneHzChar((unsigned char *)&(ptGb16[usIndex].Msk[0]), x0, y0, color);
                                                                        /* 显示字符                     */
            pcStr += 2;
        } else {                                                        /* 判断为非汉字                 */
            if (*pcStr == '\r') {                                       /* 换行                         */
                y0 = y0 + 16;                                           /* 改变显示坐标                 */
                if(y0 >= Gus_LCM_YMAX) {                                /* 纵坐标超出                   */
                    y0 = 0;
                }
                pcStr++;
                usWidth = 0;
                continue;
            } else if (*pcStr == '\n') {                                /* 对齐到起点                   */
                x0 = 0;
                pcStr++;
                usWidth = 0;
                continue;
            } else {
                if((x0 + 8) >= Gus_LCM_XMAX) {                          /* 检查剩余空间是否足够         */
                    x0 = 0;
                    y0 = y0 + 16;                                       /* 改变显示坐标                 */
                    if(y0 >= Gus_LCM_YMAX) {                            /* 纵坐标超出                   */
                        y0 = 0;
                    }
                }
                usWidth = __writeOneASCII((unsigned char *)&ASCII[(*pcStr - 0x20)][0], x0, y0, color);
                                                                        /* ASCII码表21H的值对应区位码3区*/
                pcStr += 1;
            }
        }
    }
}


/*********************************************************************************************************
** 函数名称: pixelDraw
** 功能描述: 在指定的坐标画一个点（像素）
** 输  　入: x 列坐标
**           y 行坐标
**           usValue 像素的颜色值
** 输　  出: 无
** 全局变量: 无
** 调用模块: setCoordinate()、__writeData16()
** 作  　者: 张展威
** 日　  期: 2008年7月22日
**-------------------------------------------------------------------------------------------------------
** 修 改 人:
** 日　  期:
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
void pixelDraw(unsigned short x, unsigned short y,unsigned short usValue)
{
    setCoordinate(x, y);                                                /* 坐标设置                     */
    __writeData16(usValue);                                             /* 画一个点的像素值             */
}


/*********************************************************************************************************
** 函数名称: lineDrawH
** 功能描述: 在指定位置画一水平线
** 输  　入: x1 列起始坐标
**           x2 列结束坐标
**           y 行坐标
**           usValue 线的颜色值
** 输　  出: 无
** 全局变量: 无
** 调用模块: windowset()、__writeCommand()、setCoordinate()、__writeData16()
** 作  　者: 张展威
** 日　  期: 2008年7月22日
**-------------------------------------------------------------------------------------------------------
** 修 改 人:
** 日　  期:
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
void lineDrawH(unsigned short x1, unsigned short x2, unsigned short y, unsigned short usValue)
{
    unsigned short usTmp;
    
    if (x1 > x2) {
        usTmp = x1;
        x1 = x2;
        x2 = usTmp;
    }
    if (x1 > 239) {x1 = 239;}
    if (x2 > 239) {x2 = 239;}
    
    //窗口设置
    windowset(0, y, 239, y);
    
    // 设置增长方向为：左 --> 右，上 --> 下
    __writeCommand(0,0x00,0x04);                                        /* 扫描方向控制                 */
    __writeCommand(0,0x01,0x07);                                        /* 扫描方向控制                 */
    
    setCoordinate(x1, y);                                               /* 设置起始坐标                 */
    while (x1++ <= x2) {
        __writeData16(usValue);                                         /* 画一个点的像素值             */
    }
}

/*********************************************************************************************************
** 函数名称: lineDrawV
** 功能描述: 在指定位置画一竖线
** 输  　入: x 列坐标
**           y1 行起始坐标
**           y2 行结束坐标
**           usValue 线的颜色值
** 输　  出: 无
** 全局变量: 无
** 调用模块: windowset()、__writeCommand()、setCoordinate()、__writeData16()
** 作  　者: 张展威
** 日　  期: 2008年7月22日
**-------------------------------------------------------------------------------------------------------
** 修 改 人:
** 日　  期:
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
void lineDrawV(unsigned short x, unsigned short y1, unsigned short y2, unsigned short usValue)
{
    unsigned short usTmp;
    if (y1 > y2) {
        usTmp = y1;
        y1 = y2;
        y2 = usTmp;
    }
    if (y1 > 319) {y1 = 319;}
    if (y2 > 319) {y2 = 319;}
    
    //窗口设置
    windowset(x, 0, x, 319);
    
    // 设置增长方向为：左 --> 右，上 --> 下
    __writeCommand(0,0x00,0x04);                                        /* 扫描方向控制                 */
    __writeCommand(0,0x01,0x07);                                        /* 扫描方向控制                 */
    
    setCoordinate(x, y1);                                               /* 设置起始坐标                 */
    while (y1++ <= y2) {
        __writeData16(usValue);                                         /* 画一个点的像素值             */
    }
}


/*********************************************************************************************************
** 函数名称: rectFill
** 功能描述: 用颜色值ulValue填充pRect所指定的区域
** 输  　入: pRect 指向矩形区域结构体变量的指针
**           ulValue 颜色值
** 输　  出: 无
** 全局变量: 无
** 调用模块: windowset()、__writeCommand()、setCoordinate()、__writeData16()
** 返    回：无
** 作  　者: 张展威
** 日　  期: 2008年7月22日
**------------------------------------------------------------------------------------------------------
** 修 改 人:
** 日　  期:
**------------------------------------------------------------------------------------------------------
*********************************************************************************************************/
void rectFill(RECTANGLE *pRect, unsigned long ulValue)
{
    long lCount;
    
    //扫描方向控制
    __writeCommand(0,0x00,0x04);                                        /* 扫描方向控制                 */
    __writeCommand(0,0x01,0x07);                                        /* 扫描方向控制                 */
    
    //窗口设置
    windowset(pRect->usXMin, pRect->usYMin, pRect->usXMax, pRect->usYMax);
    
    setCoordinate(pRect->usXMin, pRect->usYMin);                        /* 设置起始坐标                 */
    lCount = (pRect->usXMax - pRect->usXMin + 1) * (pRect->usYMax - pRect->usYMin + 1);
    while(lCount-- > 0) {
        __writeData16(ulValue);                                         /* 发送像素值                   */
    }
    
    // 复位矩形窗口
    windowset(0, 0, 239, 319);
}


/*********************************************************************************************************
** 函数名称: windowExactlySet
** 功能描述: 根据pRect指向的参数精确设置窗口（包括坐标在窗口内部的偏移量），并为写数据做好了准备
** 输  　入: pRect 指向矩形区域结构体变量的指针
** 输　  出: 无
** 全局变量: 无
** 调用模块: windowset()、__writeCommand()、setCoordinate()
** 返    回：无
** 作  　者: 张展威
** 日　  期: 2008年7月22日
**------------------------------------------------------------------------------------------------------
** 修 改 人:
** 日　  期:
**------------------------------------------------------------------------------------------------------
*********************************************************************************************************/
void windowExactlySet(RECTANGLE *pRect)
{
    //窗口设置
    windowset(pRect->usXMin, pRect->usYMin, pRect->usXMax, pRect->usYMax);
    
    // 设置增长方向为：左 --> 右，上 --> 下
    __writeCommand(0,0x00,0x04);                                        /* 扫描方向控制                 */
    __writeCommand(0,0x01,0x07);                                        /* 扫描方向控制                 */
    
    setCoordinate(pRect->usXMin + pRect->usXinZoon, pRect->usYMin + pRect->usYinZoon);
                                                                        /* 设置当前的坐标               */
}



/*********************************************************************************************************
** 函数名称: pictureFill
** 功能描述: 向psZone指向的矩形区域填充 16 bitRGB 格式的图片数据
** 输  　入: psZone 指向矩形区域结构体变量的指针
**           pusValue 指向图片数据的起始地址
**           ulCounter 需要填充的像素个数
** 输　  出: 无
** 全局变量: 无
** 调用模块: windowExactlySet()、__writeData16()、windowset()
** 返    回：无
** 作  　者: 张展威
** 日　  期: 2008年7月22日
**------------------------------------------------------------------------------------------------------
** 修 改 人:
** 日　  期:
**------------------------------------------------------------------------------------------------------
*********************************************************************************************************/
void pictureFill(RECTANGLE *psZone, unsigned short *pusValue, unsigned long ulCounter)
{
    unsigned long i = 0;
    unsigned short *pusValueptr = pusValue;
    RECTANGLE *pRect;
    
    pRect = psZone;
    
    windowExactlySet(psZone);
    for(i = 0; i < ulCounter; i++) {
        __writeData16(*pusValueptr++);                                  /* 发送像素值                   */
    }
    
    pRect->usXinZoon = pRect->usXinZoon + ulCounter;
    if (pRect->usXinZoon > (pRect->usXMax - pRect->usXMin + 1)) {
        pRect->usYinZoon += pRect->usXinZoon  / (pRect->usXMax - pRect->usXMin + 1);
        pRect->usXinZoon  = pRect->usXinZoon  % (pRect->usXMax - pRect->usXMin + 1);
        if (pRect->usYinZoon > (pRect->usYMax - pRect->usYMin + 1)) {
            pRect->usYinZoon = 0;
        }
    }
    
    // 复位矩形窗口
    windowset(0, 0, 239, 319);
}



/*********************************************************************************************************
** 函数名称: pictureFill8
** 功能描述: 向psZone指向的矩形区域填充 8 bitRGB 格式的图片数据
** 输  　入: psZone 指向矩形区域结构体变量的指针
**           pusValue 指向图片数据的起始地址
**           ulCounter 需要填充的像素个数
** 输　  出: 无
** 全局变量: 无
** 调用模块: windowExactlySet()、__writeData16()、windowset()
** 返    回：无
** 作  　者: 张展威
** 日　  期: 2008年7月22日
**------------------------------------------------------------------------------------------------------
** 修 改 人:
** 日　  期:
**------------------------------------------------------------------------------------------------------
*********************************************************************************************************/
void pictureFill8(RECTANGLE *psZone, unsigned char *pusValue, unsigned long ulCounter)
{
    unsigned long i = 0;
    unsigned char *pusValueptr = pusValue;
    unsigned short j;
    RECTANGLE *pRect;
    
    pRect = psZone;
    
    windowExactlySet(psZone);
    for(i = 0; i < ulCounter; i++) {
        j = *pusValueptr++;
        j = (((j & 0xE0) << 8)|((j & 0x1C) << 6)|((j & 0x03) << 3));
       __writeData16(j);                                  /* 发送像素值                   */
    }
    
    pRect->usXinZoon = pRect->usXinZoon + ulCounter;
    if (pRect->usXinZoon > (pRect->usXMax - pRect->usXMin + 1)) {
        pRect->usYinZoon += pRect->usXinZoon  / (pRect->usXMax - pRect->usXMin + 1);
        pRect->usXinZoon  = pRect->usXinZoon  % (pRect->usXMax - pRect->usXMin + 1);
        if (pRect->usYinZoon > (pRect->usYMax - pRect->usYMin + 1)) {
            pRect->usYinZoon = 0;
        }
    }
    
    // 复位矩形窗口
    windowset(0, 0, 239, 319);
}




/*********************************************************************************************************
像素格式转换 将 24-bit RGB 格式转换为 5-6-5 RGB 格式
*********************************************************************************************************/
unsigned long colorTranslate(unsigned long ulValue)
{
    return (((ulValue & 0x00F80000) >> 8) |
            ((ulValue & 0x0000FC00) >> 5) |
            ((ulValue & 0x000000F8) >> 3));
}


/*********************************************************************************************************
屏幕刷新
*********************************************************************************************************/
void screenFlush(void *pvDisplayData)
{
    ;
}


/*********************************************************************************************************
开背景灯
*********************************************************************************************************/
void backlightOn(void)
{
    LCD_EN = 0xFF;
}


/*********************************************************************************************************
关背景灯
*********************************************************************************************************/
void backlightOff(void)
{
    LCD_EN = 0x00;
}


/*********************************************************************************************************
** 函数名称: picture_Show
** 功能描述: 向指定区域添图
** 输  　入: *path为图片名
             xmin为图片最小横坐标
             ymin为图片最小纵坐标
             xmax为图片最大横坐标
             ymax为图片最大纵坐标           
** 输　  出: 无
** 全局变量: 无
** 调用模块: windowExactlySet()、__writeData16()、windowset()
** 返    回：无
** 作  　者: 张展威
** 日　  期: 2008年7月22日
**------------------------------------------------------------------------------------------------------
** 修 改 人:
** 日　  期:
**------------------------------------------------------------------------------------------------------
*********************************************************************************************************/
void picture_Show(const char *path,
                  unsigned short xmin,
                  unsigned short ymin,
                  unsigned short xmax,
                  unsigned short ymax)
{
    int x_long;
    int y_long;
    int xunhuancishu;
    int i;
    int j=0;
    RECTANGLE Gt_picture_Show_Zoon;
    FATFS fs;              // Work area (file system object) for logical drive
    FIL fsrc;              // file objects
    BYTE buffer[240*4];    // file copy buffer
    FRESULT res;           // FatFs function common result code
    WORD br;               // File R/W count
    x_long = xmax-xmin+1;
    y_long = ymax-ymin+1;
    xunhuancishu = y_long/2;
    //while(1){
    f_mount(0, &fs);
    //if(k==3)k=0;
    //res = f_open(&fsrc, "flawor.bin", FA_OPEN_EXISTING | FA_READ);
    res = f_open(&fsrc, path, FA_OPEN_EXISTING | FA_READ);
    //res = f_open(&fsrc, path, FA_OPEN_EXISTING | FA_READ);
    if(res == FR_OK){
        for(i=1; i<=xunhuancishu; i++){
            res = f_lseek(&fsrc, j);
            res = f_read(&fsrc, buffer, x_long*4, &br);
            buffer[res] = 0;
            Gt_picture_Show_Zoon.usXMin = xmin;
            Gt_picture_Show_Zoon.usYMin = ymin+(i-1)*2;
            Gt_picture_Show_Zoon.usXMax = xmax;
            Gt_picture_Show_Zoon.usYMax = ymin+i*2-1;
            Gt_picture_Show_Zoon.usXinZoon = 0;
            Gt_picture_Show_Zoon.usYinZoon = 0;
            pictureFill((RECTANGLE *)&Gt_picture_Show_Zoon, (unsigned short *)buffer, x_long * 2);
            j = j+x_long*4;
        }
        f_close(&fsrc);
    }
    f_mount(0, NULL);
}

/*********************************************************************************************************
** End of File
*********************************************************************************************************/
